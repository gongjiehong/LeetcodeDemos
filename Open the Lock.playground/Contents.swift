import UIKit

/// BFS 最小路径框架

//// 计算从起点 start 到终点 target 的最近距离
//int BFS(Node start, Node target) {
//    Queue<Node> q; // 核心数据结构
//    Set<Node> visited; // 避免走回头路
//
//    q.offer(start); // 将起点加入队列
//    visited.add(start);
//    int step = 0; // 记录扩散的步数
//
//    while (q not empty) {
//        int sz = q.size();
//        /* 将当前队列中的所有节点向四周扩散 */
//        for (int i = 0; i < sz; i++) {
//            Node cur = q.poll();
//            /* 划重点：这里判断是否到达终点 */
//            if (cur is target)
//            return step;
//            /* 将 cur 的相邻节点加入队列 */
//            for (Node x : cur.adj())
//            if (x not in visited) {
//                q.offer(x);
//                visited.add(x);
//            }
//        }
//        /* 划重点：更新步数在这里 */
//        step++;
//    }
//}

class Solution {
    func openLock(_ deadends: [String], _ target: String) -> Int {
//        // 用于存储每一次处理的上下八种可能
//        var queue: [String] = []
//        // 存储已经走过的路径和死路，回头路不走（不是最优，而且会死循环），死路也不能走
//        var visitedSet: Set<String> = Set<String>()
//        for deadend in deadends {
//            visitedSet.insert(deadend)
//        }
//
//        let start = "0000"
//        queue.append(start)
//
//        var step = 0
//
//        while !queue.isEmpty {
//            let size = queue.count
//            print(visitedSet.count)
//            // 遍历现有队列，扩散队列
//            for _ in 0..<size {
//                let current = queue.removeFirst()
//
//                // 找到，终止，返回目前步数
//                if current == target {
//                    return step
//                }
//
//                // 如果已经存在，跳过不处理,不存在则加入已处理路径中
//                if visitedSet.contains(current) {
//                    continue
//                } else {
//                    visitedSet.insert(current)
//                }
//
//                // 算出前后各4种可能并加入队列，处理过的不加，死路也不加
//                for index in 0..<4 {
//                    let up = plusOne(code: current, index: index)
//                    if !visitedSet.contains(up) {
//                        queue.append(up)
//                    }
//
//                    let down = minusOne(code: current, index: index)
//                    if !visitedSet.contains(down) {
//                        queue.append(down)
//                    }
//                }
//            }
//
//            step += 1
//        }
//
//        return -1
  
        // 双向BFS算法，知道结果，同时从开头和结果开始遍历，找到交集的时候路径就连上了，也就得到了结果
        var q1 = Set<String>()
        var q2 = Set<String>()
        
        // 存储访问过的和死路节点
        var visited = Set<String>()
        for dead in deadends {
            visited.insert(dead)
        }
        
        var step = 0
        
        q1.insert("0000")
        q2.insert(target)
        
        while !q1.isEmpty && !q2.isEmpty {
            var temp = Set<String>()
            
            // 做一次交换，从较短队列展开，可以减少运算次数
            if q1.count > q2.count {
                let t = q1
                q1 = q2
                q2 = t
            }
            
            // 展开队列，如果出现了交集，说明路径连通
            for current in q1 {
                // 出现了交集，说明路径连通
                if q2.contains(current) {
                    return step
                }
                
                // 拒绝回头路和死路
                if visited.contains(current) {
                    continue
                } else {
                    visited.insert(current)
                }
                
                // 展开相邻的8种情况
                for index in 0..<4 {
                    let up = plusOne(code: current, index: index)
                    if !visited.contains(up) {
                        temp.insert(up)
                    }
                    
                    let down = minusOne(code: current, index: index)
                    if !visited.contains(down) {
                        temp.insert(down)
                    }
                }
            }
            
            step += 1
            
            // q1 在上面的外层for已经展开，所以做一次交换，再到前面的长度比较中选择短的进行扩散
            q1 = temp
        }
        return -1
    }
    
    func plusOne(code: String, index: Int) -> String {
        // 调用compactMap保证没一个Character能都转为Int，效率其实挺低下的
        var result = code.compactMap { $0.wholeNumberValue }
        if result[index] == 9 {
            result[index] = 0
        } else {
            result[index] = result[index] + 1
        }
        // 先转成String数组，再join，也是效率低下，不可取
        return result.map{String($0)}.joined()
    }
    
    func minusOne(code: String, index: Int) -> String {
        var result = code.compactMap { $0.wholeNumberValue }
        if result[index] == 0 {
            result[index] = 9
        } else {
            result[index] = result[index] - 1
        }
        return result.map{String($0)}.joined()
    }
}

Solution().openLock(["8687","6666","7686","8876","7676","6777","6876","8776","8768","8776","6776","7677","6676","7786","7768","7678","7888","6887","8788","8887","8866","8886","7876","8767","8787","6767","8788","6776","6786","8677","8687","7868","8668","7676","7668","7768","7787","8876","7876","7677","8687","7768","7768","6776","6887","6766","8687","6678","6668","7687","6686","8676","7787","7877","8766","7787","7867","6778","7767","8876","6688","8778","6776","6776","8768","8867","7876","8678","6666","6678","6787","6676","6777","7676","7786","6778","6776","6888","7866","8677","8876","8886","8776","6777","8787","7787","6678","7677","8678","8686","8866","7877","7678","6886","7876","7687","6666","7786","7767","7686","6887","6678","7886","7678","6878","6678","7868","6677","7877","8768","7688","7766","6688","8786","7877","8767","6878","7767","7678","8676","6677","8887","8687","8778","6666","6866","7788","7766","6778","8668","8677","7666","6687","6668","6788","6878","8668","7676","6768","7887","8676","8876","6767","6887","6886","7866","7886","6687","6687","8778","6787","6767","8688","7686","7678","6686","8876","7777","7786","8668","7666","7788","7876","8766","7777","6876","7868","8878","6677","7666","7777","8867","8767","6768","7767","7866","6766","8878","6777","8886","7886","7776","7786","8668","7768","7867","6686","6786","6777","7768","6678","8867","6866","8888","7667","7887","8786","8887","6877","6677","6886","8877","8677","6667","8766","6677","7668","8888","6776","6668","6866","7667","7886","7886","7788","6678","7767","8686","6776","7676","6866","6886","6786","6686","7676","8886","7666","7776","8877","6666","6867","8887","6687","7776","6888","8888","7776","8767","8767","6868","7766","7867","7777","7667","6867","7888","6777","6686","6666","7786","7878","7686","7666","8876","8686","7688","8766","8887","6776","8686","8686","7788","8887","7778","7886","7676","7668","8666","8677","7866","6676","6888","6868","7687","7687","6887","7786","6677","6788","8777","8686","6776","6887","6867","8778","6867","8768","7687","8787","8778","6668","6787","6766","6678","6667","7667","8788","7686","7887","6868","7676","8668","6786","7778","8778","8867","7787","7786","7667","8867","7888","8678","6678","6778","6767","8666","8666","7867","8677","8676","6867","7877","7888","6677","7888","8666","8788","7866","8668","7787","7787","6776","8767","6886","6777","6887","8788","7877","7766","6787","8688","7867","8777","6668","8767","6686","7888","7867","7776","6668","8687","8666","7768","8768","6678","8786","6668","6777","8788","6686","8686","8867","6676","7787","7866","6767","6786","8868","8886","6678","7868","7767","8668","8787","7778","7687","6877","8688","6787","7887","6788","6688","8768","8678","8887","6887","6888","7678","8886","6766","7676","7786","6788","8777","7666","6687","6687","6887","7867","8677","6787","7786","8788","8886","6686","7887","6678","8676","7887","8688","7667","8768","7788","6687","7876","7686","8776","7688","8868","8777","6668","8768","7686","7776","6868","8886","8866","6777","7876","7668","8676","8668","8676","6878","7867","6878","6676","8688","8866","7666","8776","7666","6876","7867","8876","8666","8666","7687","6766","6687","7776","8766","6777","6687","7767","8676","7768","8786","7788","6788","8786","6686","6676","8876","7787","6787","8886","6687","7886","8687","6878","6667","6787","8676","6676","6888","6677","8876","8778","6676","7677","8677","6667","7687","7667","7878","7788","7767","8867","7768","7878","7677","8878","7776","6686","8666","8688","8868","7776","6876"], "8667")
